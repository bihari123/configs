#!/bin/bash

# Simple but effective process tracker
# Finds and restores actual running processes

ENHANCED_STATE_FILE="$HOME/.tmux/resurrect/simple_processes.json"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Capture running processes
capture_processes() {
    echo -e "${BLUE}Scanning for running processes...${NC}"

    echo "[" > "$ENHANCED_STATE_FILE"
    local first=true

    tmux list-panes -a -F "#{session_name}:#{window_index}.#{pane_index}|#{pane_id}|#{pane_current_path}|#{pane_title}|#{pane_pid}" | while IFS='|' read -r location pane_id cwd title pane_pid; do
        # Find all processes for this pane
        local processes_found=""

        if [ -n "$pane_pid" ] && [ "$pane_pid" != "0" ]; then
            # Get main process
            local main_cmd=$(ps -p "$pane_pid" -o cmd --no-headers 2>/dev/null | xargs)
            if [ -n "$main_cmd" ]; then
                processes_found="\"$main_cmd\""
            fi

            # Find child processes
            local child_pids=$(pgrep -P "$pane_pid" 2>/dev/null | tr '\n' ' ')
            for child_pid in $child_pids; do
                if [ -n "$child_pid" ]; then
                    local child_cmd=$(ps -p "$child_pid" -o cmd --no-headers 2>/dev/null | xargs)
                    if [ -n "$child_cmd" ]; then
                        if [ -n "$processes_found" ]; then
                            processes_found="$processes_found, \"$child_cmd\""
                        else
                            processes_found="\"$child_cmd\""
                        fi
                    fi
                fi
            done
        fi

        # If no processes found, use the shell command
        if [ -z "$processes_found" ]; then
            local shell_cmd=$(tmux display-message -p -t "$pane_id" "#{pane_current_command}" 2>/dev/null || echo "bash")
            processes_found="\"$shell_cmd\""
        fi

        # Add to JSON
        if [ "$first" = false ]; then
            echo "," >> "$ENHANCED_STATE_FILE"
        fi
        first=false

        cat >> "$ENHANCED_STATE_FILE" << EOF
{
  "location": "$location",
  "pane_id": "$pane_id",
  "cwd": "$cwd",
  "title": "$title",
  "processes": [$processes_found]
}
EOF

    done

    echo "]" >> "$ENHANCED_STATE_FILE"
    echo -e "${GREEN}Captured processes to $ENHANCED_STATE_FILE${NC}"
}

# Execute processes
execute_processes() {
    local mode="${1:-auto}"  # auto or all
    local dry_run="${2:-false}"  # true or false

    echo -e "${BLUE}Executing processes in $mode mode...${NC}"

    jq -c '.[]' "$ENHANCED_STATE_FILE" 2>/dev/null | while IFS= read -r entry; do
        local location=$(echo "$entry" | jq -r '.location')
        local cwd=$(echo "$entry" | jq -r '.cwd')
        local processes=$(echo "$entry" | jq -r '.processes[]')

        IFS=':' read -r session window_pane <<< "$location"
        IFS='.' read -r window pane <<< "$window_pane"
        local target="$session:$window.$pane"

        echo -e "\n${YELLOW}Pane: $location ($cwd)${NC}"

        for process in $processes; do
            # Remove quotes
            process=$(echo "$process" | sed 's/"//g')

            if [ -z "$process" ] || [[ "$process" =~ ^bash$|^sh$|^zsh$|^fish$ ]]; then
                echo -e "  Skipping shell: $process"
                continue
            fi

            # Check if this should be auto-executed
            local should_execute="true"
            if [ "$mode" = "auto" ]; then
                # Only auto-execute certain processes
                if [[ ! "$process" =~ ^(btop|htop|top|npm|node|python|go|cargo|ssh|psql|mysql|sqlite3|vim|nvim) ]]; then
                    should_execute="false"
                fi
            fi

            if [ "$should_execute" = "true" ]; then
                echo -e "  ${GREEN}Executing: $process${NC}"

                if [ "$dry_run" = "false" ]; then
                    if tmux has-session -t "$target" 2>/dev/null; then
                        tmux send-keys -t "$target" "cd '$cwd'" Enter
                        sleep 0.2
                        tmux send-keys -t "$target" "clear" Enter
                        sleep 0.1
                        tmux send-keys -t "$target" "$process" Enter
                    else
                        echo -e "    ${RED}Target $target not found${NC}"
                    fi
                else
                    echo -e "    [DRY RUN] Would execute: $process in $target"
                fi
            else
                echo -e "  ${YELLOW}Skipping (auto mode): $process${NC}"
            fi
        done
    done
}

# Show current processes
show_processes() {
    if [ ! -f "$ENHANCED_STATE_FILE" ]; then
        echo -e "${RED}No process data available. Run capture first.${NC}"
        return 1
    fi

    echo -e "${BLUE}=== Current Running Processes ===${NC}"
    echo ""

    jq -r '.[] | "Location: \(.location)" | . + "\n  Directory: \(.cwd)\n  Title: \(.title)\n  Processes: \([.processes[] | .] | join(", "))\n"' "$ENHANCED_STATE_FILE" 2>/dev/null
}

# Main
case "${1:-capture}" in
    "capture")
        capture_processes
        show_processes
        ;;
    "auto")
        execute_processes auto false
        ;;
    "all")
        execute_processes all false
        ;;
    "dry-auto")
        execute_processes auto true
        ;;
    "dry-all")
        execute_processes all true
        ;;
    "show")
        show_processes
        ;;
    *)
        echo "Usage: $0 {capture|auto|all|dry-auto|dry-all|show}"
        echo ""
        echo "capture   - Capture running processes"
        echo "auto      - Execute auto-whitelisted processes"
        echo "all       - Execute all processes"
        echo "dry-auto  - Dry run for auto processes"
        echo "dry-all   - Dry run for all processes"
        echo "show      - Show captured processes"
        exit 1
        ;;
esac