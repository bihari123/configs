#!/bin/bash

# Enhanced tmux process manager with auto-execution and selective restoration
# Usage: tmux-process-manager [--auto] [--dry-run]

PROCESS_FILE="$HOME/.tmux/resurrect/last"
ENHANCED_STATE_FILE="$HOME/.tmux/resurrect/enhanced_state.json"
AUTO_FLAG="--auto"
DRY_RUN=false

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --auto)
            AUTO_EXEC=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        *)
            echo "Unknown option: $1"
            echo "Usage: $0 [--auto] [--dry-run]"
            exit 1
            ;;
    esac
done

# Process whitelist with auto-execution flag
declare -A AUTO_PROCESSES=(
    ["ssh"]="$AUTO_FLAG"
    ["psql"]="$AUTO_FLAG"
    ["mysql"]="$AUTO_FLAG"
    ["sqlite3"]="$AUTO_FLAG"
    ["~npm start"]="$AUTO_FLAG"
    ["~npm run dev"]="$AUTO_FLAG"
    ["~python"]="$AUTO_FLAG"
    ["~node"]="$AUTO_FLAG"
    ["~go run"]="$AUTO_FLAG"
    ["~cargo run"]="$AUTO_FLAG"
)

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Parse current tmux-resurrect state and capture live processes
parse_resurrect_state() {
    echo -e "${BLUE}Capturing current tmux panes and processes...${NC}"

    # Create enhanced state JSON
    echo "{" > "$ENHANCED_STATE_FILE"

    local first_entry=true

    # Get live process information from all tmux panes
    tmux list-panes -a -F "#{session_name}:#{window_index}.#{pane_index}|#{pane_id}|#{pane_current_command}|#{pane_current_path}|#{pane_title}|#{pane_pid}" | while IFS='|' read -r location pane_id command cwd title pid; do
        if [ "$first_entry" = false ]; then
            echo "," >> "$ENHANCED_STATE_FILE"
        fi
        first_entry=false

        # Parse location
        IFS=':' read -r session pane_id_temp <<< "$location"
        IFS='.' read -r window pane <<< "$pane_id_temp"

        # Get detailed process information
        local full_command="$command"
        local process_details=""

        if [ -n "$pid" ] && [ "$pid" != "0" ]; then
            process_details=$(ps -p "$pid" -o cmd --no-headers 2>/dev/null | tr -d '\n' || echo "$command")
            if [ -n "$process_details" ] && [ "$process_details" != "$command" ]; then
                full_command="$process_details"
            fi
        fi

        # Check for child processes in this pane
        local child_processes=""
        if [ -n "$pid" ] && [ "$pid" != "0" ]; then
            child_processes=$(pgrep -P "$pid" -l 2>/dev/null | awk '{print $2}' | tr '\n' '; ' | sed 's/; $//')
            if [ -n "$child_processes" ]; then
                full_command="$child_processes"
                command=$(echo "$child_processes" | cut -d';' -f1 | awk '{print $1}')
            fi
        fi

        # Clean up the values
        session=$(echo "$session" | tr -d '\r\n ')
        window=$(echo "$window" | tr -d '\r\n ')
        pane=$(echo "$pane" | tr -d '\r\n ')
        title=$(echo "$title" | tr -d '\r\n ')
        cwd=$(echo "$cwd" | tr -d '\r\n ')
        command=$(echo "$command" | tr -d '\r\n ')
        full_command=$(echo "$full_command" | tr -d '\r\n ')

        # Determine if process should auto-execute
        local auto_execute=false
        local whitelist_match=""

        for proc_pattern in "${!AUTO_PROCESSES[@]}"; do
            if [[ "$full_command" == *"$proc_pattern"* ]] || [[ "$command" == *"$proc_pattern"* ]]; then
                auto_execute=true
                whitelist_match="$proc_pattern"
                break
            fi
        done

        # Include all processes but mark shells as low priority
        local is_shell=false
        if [[ "$command" =~ ^(bash|zsh|fish|sh)$ ]]; then
            is_shell=true
        fi

        cat >> "$ENHANCED_STATE_FILE" << EOF
  "${location}": {
    "session": "$session",
    "window": "$window",
    "pane": "$pane",
    "title": "$title",
    "cwd": "$cwd",
    "command": "$command",
    "full_command": "$full_command",
    "is_shell": $is_shell,
    "pid": "$pid",
    "auto_execute": $auto_execute,
    "whitelist_match": "$whitelist_match",
    "executed": false,
    "skipped": false
  }
EOF
    done

    echo "}" >> "$ENHANCED_STATE_FILE"
}

# Execute process in specific pane
execute_process() {
    local session="$1"
    local window="$2"
    local pane="$3"
    local command="$4"
    local cwd="$5"
    local target="${session}:${window}.${pane}"

    if [ "$DRY_RUN" = true ]; then
        echo -e "${YELLOW}[DRY RUN] Would execute in $target: $command${NC}"
        return 0
    fi

    # Check if the session/window/pane exists
    if ! tmux has-session -t "$target" 2>/dev/null; then
        echo -e "${RED}Session/pane $target not found. Skipping.${NC}"
        return 1
    fi

    # Execute the command in the target pane
    echo -e "${GREEN}Executing in $target: $command${NC}"
    tmux send-keys -t "$target" "cd '$cwd'" Enter
    sleep 0.1
    tmux send-keys -t "$target" "$command" Enter

    return 0
}

# Auto-execute whitelisted processes
auto_execute_processes() {
    echo -e "${GREEN}Auto-executing whitelisted processes...${NC}"

    local auto_count=0

    jq -r 'to_entries[] | select(.value.auto_execute == true) | "\(.key)|\(.value.full_command)|\(.value.cwd)"' "$ENHANCED_STATE_FILE" 2>/dev/null | while IFS='|' read -r location command cwd; do
        IFS=':' read -r session pane_id <<< "$location"
        IFS='.' read -r window pane <<< "$pane_id"

        if [ -n "$location" ] && [ -n "$command" ]; then
            execute_process "$session" "$window" "$pane" "$command" "$cwd"

            # Mark as executed in JSON
            if [ "$DRY_RUN" = false ]; then
                jq --arg key "$location" 'setpath([$key, "executed"]; true)' "$ENHANCED_STATE_FILE" > "${ENHANCED_STATE_FILE}.tmp" && mv "${ENHANCED_STATE_FILE}.tmp" "$ENHANCED_STATE_FILE"
            fi

            ((auto_count++))
        fi
    done

    echo -e "${GREEN}Auto-executed $auto_count processes.${NC}"
}

# Show processes for manual confirmation
show_manual_processes() {
    echo -e "\n${YELLOW}Available panes and suggested commands:${NC}"
    echo -e "${BLUE}Press Enter to execute suggested command, type your own, or 's' to skip.${NC}"
    echo ""

    local manual_count=0

    jq -r 'to_entries[] | .value | "\(.session):\(.window).\(.pane)|\(.cwd)|\(.title)|\(.is_shell)"' "$ENHANCED_STATE_FILE" 2>/dev/null | while IFS='|' read -r location cwd title is_shell; do
        if [ -z "$location" ]; then
            continue
        fi

        ((manual_count++))

        IFS=':' read -r session pane_id <<< "$location"
        IFS='.' read -r window pane <<< "$pane_id"

        # Suggest commands based on directory and context
        local suggested_command=""
        if [ "$is_shell" = "true" ]; then
            if [[ "$cwd" == *"config"* ]]; then
                suggested_command="ls -la"
            elif [[ "$cwd" == *"nvim"* ]]; then
                suggested_command="nvim ."
            elif [[ "$cwd" == *"build"* ]]; then
                suggested_command="make || ninja || echo 'No build system found'"
            else
                suggested_command="git status"
            fi
        else
            suggested_command="echo 'Continue current work'"
        fi

        echo -e "\n${YELLOW}[$manual_count] $location${NC}"
        echo -e "  Title: $title"
        echo -e "  Directory: $cwd"
        echo -e "  Type: $([ "$is_shell" = "true" ] && echo "Shell" || echo "Process")"
        echo -e "  Suggested: ${GREEN}$suggested_command${NC}"
        echo -n -e "  Execute? [Enter=$suggested_command | custom | s=skip]: "

        if [ "$AUTO_EXEC" = true ]; then
            echo "y (auto mode)"
            execute_process "$session" "$window" "$pane" "$suggested_command" "$cwd"
            jq --arg key "$location" 'setpath([$key, "executed"]; true)' "$ENHANCED_STATE_FILE" > "${ENHANCED_STATE_FILE}.tmp" && mv "${ENHANCED_STATE_FILE}.tmp" "$ENHANCED_STATE_FILE"
        else
            # Interactive mode
            read -r response
            case "$response" in
                "y"|"Y"|"")
                    execute_process "$session" "$window" "$pane" "$suggested_command" "$cwd"
                    jq --arg key "$location" 'setpath([$key, "executed"]; true)' "$ENHANCED_STATE_FILE" > "${ENHANCED_STATE_FILE}.tmp" && mv "${ENHANCED_STATE_FILE}.tmp" "$ENHANCED_STATE_FILE"
                    ;;
                "s"|"S")
                    echo -e "${RED}Skipped${NC}"
                    jq --arg key "$location" 'setpath([$key, "skipped"]; true)' "$ENHANCED_STATE_FILE" > "${ENHANCED_STATE_FILE}.tmp" && mv "${ENHANCED_STATE_FILE}.tmp" "$ENHANCED_STATE_FILE"
                    ;;
                "q"|"Q")
                    echo -e "${YELLOW}Quitting manual execution${NC}"
                    break
                    ;;
                *)
                    if [ -n "$response" ]; then
                        echo -e "${BLUE}Executing custom command: $response${NC}"
                        execute_process "$session" "$window" "$pane" "$response" "$cwd"
                        jq --arg key "$location" 'setpath([$key, "executed"]; true)' "$ENHANCED_STATE_FILE" > "${ENHANCED_STATE_FILE}.tmp" && mv "${ENHANCED_STATE_FILE}.tmp" "$ENHANCED_STATE_FILE"
                    else
                        echo -e "${YELLOW}Skipped${NC}"
                        jq --arg key "$location" 'setpath([$key, "skipped"]; true)' "$ENHANCED_STATE_FILE" > "${ENHANCED_STATE_FILE}.tmp" && mv "${ENHANCED_STATE_FILE}.tmp" "$ENHANCED_STATE_FILE"
                    fi
                    ;;
            esac
        fi
    done
}

# Show summary
show_summary() {
    echo -e "\n${BLUE}=== Process Restoration Summary ===${NC}"

    local total=$(jq '. | length' "$ENHANCED_STATE_FILE" 2>/dev/null || echo "0")
    local executed=$(jq '[.[] | select(.executed == true)] | length' "$ENHANCED_STATE_FILE" 2>/dev/null || echo "0")
    local skipped=$(jq '[.[] | select(.skipped == true)] | length' "$ENHANCED_STATE_FILE" 2>/dev/null || echo "0")
    local pending=$(jq '[.[] | select(.executed == false and .skipped == false)] | length' "$ENHANCED_STATE_FILE" 2>/dev/null || echo "0")

    echo -e "Total processes: $total"
    echo -e "Executed: ${GREEN}$executed${NC}"
    echo -e "Skipped: ${RED}$skipped${NC}"
    echo -e "Pending: ${YELLOW}$pending${NC}"

    if [ "$pending" -gt 0 ]; then
        echo -e "\n${YELLOW}Pending processes:${NC}"
        jq -r 'to_entries[] | select(.value.executed == false and .value.skipped == false) | "  \(.key): \(.value.full_command)"' "$ENHANCED_STATE_FILE" 2>/dev/null
    fi
}

# Main execution
main() {
    echo -e "${BLUE}=== Enhanced Tmux Process Manager ===${NC}"

    if [ "$AUTO_EXEC" = true ]; then
        echo -e "${GREEN}Auto-execution mode enabled${NC}"
    fi

    if [ "$DRY_RUN" = true ]; then
        echo -e "${YELLOW}Dry run mode - no actual execution${NC}"
    fi

    parse_resurrect_state

    if [ "$AUTO_EXEC" = true ]; then
        auto_execute_processes
    else
        auto_execute_processes
        show_manual_processes
    fi

    show_summary

    echo -e "\n${GREEN}Process management complete!${NC}"
    echo "Enhanced state saved to: $ENHANCED_STATE_FILE"
}

main "$@"